/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_screen {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_application {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_application_options {
    _unused: [u8; 0],
}
pub const SAUCER_POLICY_ALLOW: saucer_policy = 0;
pub const SAUCER_POLICY_BLOCK: saucer_policy = 1;
pub type saucer_policy = u8;
pub const SAUCER_APPLICATION_EVENT_QUIT: saucer_application_event = 0;
pub type saucer_application_event = ::std::os::raw::c_int;
pub type saucer_application_event_quit = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_application, arg2: *mut ::std::os::raw::c_void) -> saucer_policy,
>;
unsafe extern "C" {
    pub fn saucer_screen_free(arg1: *mut saucer_screen);
}
unsafe extern "C" {
    pub fn saucer_screen_name(arg1: *mut saucer_screen) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_screen_size(arg1: *mut saucer_screen, w: *mut ::std::os::raw::c_int, h: *mut ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_screen_position(
        arg1: *mut saucer_screen,
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @note The application options can be safely free'd after creating an application instance."]
    pub fn saucer_application_options_free(arg1: *mut saucer_application_options);
}
unsafe extern "C" {
    pub fn saucer_application_options_new(id: *const ::std::os::raw::c_char) -> *mut saucer_application_options;
}
unsafe extern "C" {
    pub fn saucer_application_options_set_argc(arg1: *mut saucer_application_options, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_application_options_set_argv(
        arg1: *mut saucer_application_options,
        arg2: *mut *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn saucer_application_options_set_quit_on_last_window_closed(arg1: *mut saucer_application_options, arg2: bool);
}
unsafe extern "C" {
    #[doc = " @attention Please call this after \\see{saucer_application_run} returned and not in the finish callback or\n similar."]
    pub fn saucer_application_free(arg1: *mut saucer_application);
}
unsafe extern "C" {
    pub fn saucer_application_new(
        arg1: *mut saucer_application_options,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut saucer_application;
}
unsafe extern "C" {
    pub fn saucer_application_thread_safe(arg1: *mut saucer_application) -> bool;
}
unsafe extern "C" {
    pub fn saucer_application_screens(arg1: *mut saucer_application, arg2: *mut *mut saucer_screen, size: *mut usize);
}
pub type saucer_post_callback = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn saucer_application_post(
        arg1: *mut saucer_application,
        arg2: saucer_post_callback,
        userdata: *mut ::std::os::raw::c_void,
    );
}
pub type saucer_run_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut saucer_application, arg2: *mut ::std::os::raw::c_void)>;
pub type saucer_finish_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut saucer_application, arg2: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn saucer_application_quit(arg1: *mut saucer_application);
}
unsafe extern "C" {
    #[doc = " @note This approximates the run function that uses coroutines. The run callback is called once the application is\n ready, then `co_await app->finish()` is called internally, afterwards, the finish callback is invoked.\n @attention You might want to use the loop module instead."]
    pub fn saucer_application_run(
        arg1: *mut saucer_application,
        arg2: saucer_run_callback,
        arg3: saucer_finish_callback,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn saucer_application_on(
        arg1: *mut saucer_application,
        arg2: saucer_application_event,
        callback: *mut ::std::os::raw::c_void,
        clearable: bool,
        userdata: *mut ::std::os::raw::c_void,
    ) -> usize;
}
unsafe extern "C" {
    pub fn saucer_application_once(
        arg1: *mut saucer_application,
        arg2: saucer_application_event,
        callback: *mut ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn saucer_application_off(arg1: *mut saucer_application, arg2: saucer_application_event, arg3: usize);
}
unsafe extern "C" {
    pub fn saucer_application_off_all(arg1: *mut saucer_application, arg2: saucer_application_event);
}
unsafe extern "C" {
    #[doc = " @brief Allows to access the stable natives of saucer::application.\n @param idx The index of the member to return, e.g. `0` to access the `AdwApplication *` of the webkitgtk natives.\n @param result A pointer to a buffer into which the member will be extracted.\n @param size The size of the buffer.\n @note To use this function, call it first with \\param{result} being `nullptr`, and \\param{size} pointing to a\n variable that will receive the required buffer size. Then call it again with \\param{result} pointing to a buffer\n with sufficient size. Leave \\param{size} unchanged in the second invocation."]
    pub fn saucer_application_native(
        arg1: *mut saucer_application,
        idx: usize,
        result: *mut ::std::os::raw::c_void,
        size: *mut usize,
    );
}
unsafe extern "C" {
    #[doc = " @note The returned string does not need to be free'd."]
    pub fn saucer_version() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_stash {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn saucer_stash_data(arg1: *mut saucer_stash) -> *const u8;
}
unsafe extern "C" {
    pub fn saucer_stash_size(arg1: *mut saucer_stash) -> usize;
}
pub type saucer_stash_lazy_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut saucer_stash>;
unsafe extern "C" {
    pub fn saucer_stash_free(arg1: *mut saucer_stash);
}
unsafe extern "C" {
    pub fn saucer_stash_copy(arg1: *mut saucer_stash) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_stash_new_from(arg1: *mut u8, arg2: usize) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_stash_new_view(arg1: *const u8, arg2: usize) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_stash_new_lazy(
        arg1: saucer_stash_lazy_callback,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_stash_new_from_str(arg1: *const ::std::os::raw::c_char) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_stash_new_view_str(arg1: *const ::std::os::raw::c_char) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_stash_new_empty() -> *mut saucer_stash;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_icon {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn saucer_icon_empty(arg1: *mut saucer_icon) -> bool;
}
unsafe extern "C" {
    pub fn saucer_icon_data(arg1: *mut saucer_icon) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_icon_save(arg1: *mut saucer_icon, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_icon_free(arg1: *mut saucer_icon);
}
unsafe extern "C" {
    pub fn saucer_icon_copy(arg1: *mut saucer_icon) -> *mut saucer_icon;
}
unsafe extern "C" {
    pub fn saucer_icon_new_from_file(
        arg1: *const ::std::os::raw::c_char,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut saucer_icon;
}
unsafe extern "C" {
    pub fn saucer_icon_new_from_stash(arg1: *mut saucer_stash, error: *mut ::std::os::raw::c_int) -> *mut saucer_icon;
}
unsafe extern "C" {
    #[doc = " @note Please refer to the documentation in `application.h` on how to use this function."]
    pub fn saucer_icon_native(arg1: *mut saucer_icon, arg2: usize, arg3: *mut ::std::os::raw::c_void, arg4: *mut usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_url {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn saucer_url_free(arg1: *mut saucer_url);
}
unsafe extern "C" {
    pub fn saucer_url_copy(arg1: *mut saucer_url) -> *mut saucer_url;
}
unsafe extern "C" {
    pub fn saucer_url_new_parse(
        arg1: *const ::std::os::raw::c_char,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut saucer_url;
}
unsafe extern "C" {
    pub fn saucer_url_new_from(
        arg1: *const ::std::os::raw::c_char,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut saucer_url;
}
unsafe extern "C" {
    pub fn saucer_url_new_opts(
        scheme: *const ::std::os::raw::c_char,
        host: *const ::std::os::raw::c_char,
        port: *mut usize,
        path: *const ::std::os::raw::c_char,
    ) -> *mut saucer_url;
}
unsafe extern "C" {
    pub fn saucer_url_string(arg1: *mut saucer_url, arg2: *mut ::std::os::raw::c_char, arg3: *mut usize);
}
unsafe extern "C" {
    pub fn saucer_url_path(arg1: *mut saucer_url, arg2: *mut ::std::os::raw::c_char, arg3: *mut usize);
}
unsafe extern "C" {
    pub fn saucer_url_scheme(arg1: *mut saucer_url, arg2: *mut ::std::os::raw::c_char, arg3: *mut usize);
}
unsafe extern "C" {
    #[doc = " @note The url might not contain a host. If this is the case, \\param{size} will be set to 0."]
    pub fn saucer_url_host(arg1: *mut saucer_url, arg2: *mut ::std::os::raw::c_char, arg3: *mut usize);
}
unsafe extern "C" {
    #[doc = " @note The url might not contain a port. If this is the case, \\param{port} will be left unchanged and `false` will\n be returned."]
    pub fn saucer_url_port(arg1: *mut saucer_url, arg2: *mut usize) -> bool;
}
unsafe extern "C" {
    #[doc = " @note The url might not contain a user. If this is the case, \\param{size} will be set to 0."]
    pub fn saucer_url_user(arg1: *mut saucer_url, arg2: *mut ::std::os::raw::c_char, arg3: *mut usize);
}
unsafe extern "C" {
    #[doc = " @note The url might not contain a password. If this is the case, \\param{size} will be set to 0."]
    pub fn saucer_url_password(arg1: *mut saucer_url, arg2: *mut ::std::os::raw::c_char, arg3: *mut usize);
}
unsafe extern "C" {
    #[doc = " @note Please refer to the documentation in `application.h` on how to use this function."]
    pub fn saucer_url_native(arg1: *mut saucer_url, arg2: usize, arg3: *mut ::std::os::raw::c_void, arg4: *mut usize);
}
#[doc = " @remark A navigation cannot be copied."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_navigation {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn saucer_navigation_url(arg1: *mut saucer_navigation) -> *mut saucer_url;
}
unsafe extern "C" {
    pub fn saucer_navigation_new_window(arg1: *mut saucer_navigation) -> bool;
}
unsafe extern "C" {
    pub fn saucer_navigation_redirection(arg1: *mut saucer_navigation) -> bool;
}
unsafe extern "C" {
    pub fn saucer_navigation_user_initiated(arg1: *mut saucer_navigation) -> bool;
}
#[doc = " @remark Permission-Requests are reference counted. Please make sure to free all copies to properly release it!"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_permission_request {
    _unused: [u8; 0],
}
pub const SAUCER_PERMISSION_TYPE_UNKNOWN: saucer_permission_type = 0;
pub const SAUCER_PERMISSION_TYPE_AUDIO_MEDIA: saucer_permission_type = 1;
pub const SAUCER_PERMISSION_TYPE_VIDEO_MEDIA: saucer_permission_type = 2;
pub const SAUCER_PERMISSION_TYPE_DESKTOP_MEDIA: saucer_permission_type = 4;
pub const SAUCER_PERMISSION_TYPE_MOUSE_LOCK: saucer_permission_type = 8;
pub const SAUCER_PERMISSION_TYPE_DEVICE_INFO: saucer_permission_type = 16;
pub const SAUCER_PERMISSION_TYPE_LOCATION: saucer_permission_type = 32;
pub const SAUCER_PERMISSION_TYPE_CLIPBOARD: saucer_permission_type = 64;
pub const SAUCER_PERMISSION_TYPE_NOTIFICATION: saucer_permission_type = 128;
pub type saucer_permission_type = u8;
unsafe extern "C" {
    pub fn saucer_permission_request_free(arg1: *mut saucer_permission_request);
}
unsafe extern "C" {
    pub fn saucer_permission_request_copy(arg1: *mut saucer_permission_request) -> *mut saucer_permission_request;
}
unsafe extern "C" {
    pub fn saucer_permission_request_url(arg1: *mut saucer_permission_request) -> *mut saucer_url;
}
unsafe extern "C" {
    pub fn saucer_permission_request_type(arg1: *mut saucer_permission_request) -> saucer_permission_type;
}
unsafe extern "C" {
    pub fn saucer_permission_request_accept(arg1: *mut saucer_permission_request, arg2: bool);
}
unsafe extern "C" {
    #[doc = " @note Please refer to the documentation in `application.h` on how to use this function."]
    pub fn saucer_permission_request_native(
        arg1: *mut saucer_permission_request,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_scheme_executor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_scheme_request {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_scheme_response {
    _unused: [u8; 0],
}
pub const SAUCER_SCHEME_ERROR_NOT_FOUND: saucer_scheme_error = 404;
pub const SAUCER_SCHEME_ERROR_INVALID: saucer_scheme_error = 400;
pub const SAUCER_SCHEME_ERROR_DENIED: saucer_scheme_error = 401;
pub const SAUCER_SCHEME_ERROR_FAILED: saucer_scheme_error = -1;
pub type saucer_scheme_error = i16;
unsafe extern "C" {
    pub fn saucer_scheme_response_free(arg1: *mut saucer_scheme_response);
}
unsafe extern "C" {
    pub fn saucer_scheme_response_new(
        arg1: *mut saucer_stash,
        mime: *const ::std::os::raw::c_char,
    ) -> *mut saucer_scheme_response;
}
unsafe extern "C" {
    pub fn saucer_scheme_response_append_header(
        arg1: *mut saucer_scheme_response,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn saucer_scheme_response_set_status(arg1: *mut saucer_scheme_response, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_scheme_request_free(arg1: *mut saucer_scheme_request);
}
unsafe extern "C" {
    pub fn saucer_scheme_request_copy(arg1: *mut saucer_scheme_request) -> *mut saucer_scheme_request;
}
unsafe extern "C" {
    pub fn saucer_scheme_request_url(arg1: *mut saucer_scheme_request) -> *mut saucer_url;
}
unsafe extern "C" {
    pub fn saucer_scheme_request_method(
        arg1: *mut saucer_scheme_request,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
    );
}
unsafe extern "C" {
    pub fn saucer_scheme_request_content(arg1: *mut saucer_scheme_request) -> *mut saucer_stash;
}
unsafe extern "C" {
    #[doc = " @remark Headers are returned null delimited, e.g. as \"Header: Value\\0Another Header: Value\""]
    pub fn saucer_scheme_request_headers(
        arg1: *mut saucer_scheme_request,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
    );
}
unsafe extern "C" {
    pub fn saucer_scheme_executor_free(arg1: *mut saucer_scheme_executor);
}
unsafe extern "C" {
    pub fn saucer_scheme_executor_copy(arg1: *mut saucer_scheme_executor) -> *mut saucer_scheme_executor;
}
unsafe extern "C" {
    pub fn saucer_scheme_executor_reject(arg1: *mut saucer_scheme_executor, arg2: saucer_scheme_error);
}
unsafe extern "C" {
    pub fn saucer_scheme_executor_accept(arg1: *mut saucer_scheme_executor, arg2: *mut saucer_scheme_response);
}
pub type saucer_scheme_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut saucer_scheme_request,
        arg2: *mut saucer_scheme_executor,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_window {
    _unused: [u8; 0],
}
pub const SAUCER_WINDOW_EDGE_TOP: saucer_window_edge = 1;
pub const SAUCER_WINDOW_EDGE_BOTTOM: saucer_window_edge = 2;
pub const SAUCER_WINDOW_EDGE_LEFT: saucer_window_edge = 4;
pub const SAUCER_WINDOW_EDGE_RIGHT: saucer_window_edge = 8;
pub const SAUCER_WINDOW_EDGE_BOTTOM_LEFT: saucer_window_edge = 6;
pub const SAUCER_WINDOW_EDGE_BOTTOM_RIGHT: saucer_window_edge = 10;
pub const SAUCER_WINDOW_EDGE_TOP_LEFT: saucer_window_edge = 5;
pub const SAUCER_WINDOW_EDGE_TOP_RIGHT: saucer_window_edge = 9;
pub type saucer_window_edge = u8;
pub const SAUCER_WINDOW_DECORATION_NONE: saucer_window_decoration = 0;
pub const SAUCER_WINDOW_DECORATION_PARTIAL: saucer_window_decoration = 1;
pub const SAUCER_WINDOW_DECORATION_FULL: saucer_window_decoration = 2;
pub type saucer_window_decoration = u8;
pub const SAUCER_WINDOW_EVENT_DECORATED: saucer_window_event = 0;
pub const SAUCER_WINDOW_EVENT_MAXIMIZE: saucer_window_event = 1;
pub const SAUCER_WINDOW_EVENT_MINIMIZE: saucer_window_event = 2;
pub const SAUCER_WINDOW_EVENT_CLOSED: saucer_window_event = 3;
pub const SAUCER_WINDOW_EVENT_RESIZE: saucer_window_event = 4;
pub const SAUCER_WINDOW_EVENT_FOCUS: saucer_window_event = 5;
pub const SAUCER_WINDOW_EVENT_CLOSE: saucer_window_event = 6;
pub type saucer_window_event = ::std::os::raw::c_int;
pub type saucer_window_event_decorated = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_window, arg2: saucer_window_decoration, arg3: *mut ::std::os::raw::c_void),
>;
pub type saucer_window_event_maximize = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_window, arg2: bool, arg3: *mut ::std::os::raw::c_void),
>;
pub type saucer_window_event_minimize = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_window, arg2: bool, arg3: *mut ::std::os::raw::c_void),
>;
pub type saucer_window_event_closed =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut saucer_window, arg2: *mut ::std::os::raw::c_void)>;
pub type saucer_window_event_resize = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut saucer_window,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
    ),
>;
pub type saucer_window_event_focus = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_window, arg2: bool, arg3: *mut ::std::os::raw::c_void),
>;
pub type saucer_window_event_close = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_window, arg2: *mut ::std::os::raw::c_void) -> saucer_policy,
>;
unsafe extern "C" {
    pub fn saucer_window_free(arg1: *mut saucer_window);
}
unsafe extern "C" {
    pub fn saucer_window_new(arg1: *mut saucer_application, error: *mut ::std::os::raw::c_int) -> *mut saucer_window;
}
unsafe extern "C" {
    pub fn saucer_window_visible(arg1: *mut saucer_window) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_focused(arg1: *mut saucer_window) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_minimized(arg1: *mut saucer_window) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_maximized(arg1: *mut saucer_window) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_resizable(arg1: *mut saucer_window) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_fullscreen(arg1: *mut saucer_window) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_always_on_top(arg1: *mut saucer_window) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_click_through(arg1: *mut saucer_window) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_title(arg1: *mut saucer_window, arg2: *mut ::std::os::raw::c_char, arg3: *mut usize);
}
unsafe extern "C" {
    pub fn saucer_window_background(arg1: *mut saucer_window, r: *mut u8, g: *mut u8, b: *mut u8, a: *mut u8);
}
unsafe extern "C" {
    pub fn saucer_window_decorations(arg1: *mut saucer_window) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn saucer_window_size(arg1: *mut saucer_window, w: *mut ::std::os::raw::c_int, h: *mut ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_window_max_size(
        arg1: *mut saucer_window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_window_min_size(
        arg1: *mut saucer_window,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_window_position(
        arg1: *mut saucer_window,
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_window_screen(arg1: *mut saucer_window) -> *mut saucer_screen;
}
unsafe extern "C" {
    pub fn saucer_window_hide(arg1: *mut saucer_window);
}
unsafe extern "C" {
    pub fn saucer_window_show(arg1: *mut saucer_window);
}
unsafe extern "C" {
    pub fn saucer_window_close(arg1: *mut saucer_window);
}
unsafe extern "C" {
    pub fn saucer_window_focus(arg1: *mut saucer_window);
}
unsafe extern "C" {
    pub fn saucer_window_start_drag(arg1: *mut saucer_window);
}
unsafe extern "C" {
    pub fn saucer_window_start_resize(arg1: *mut saucer_window, arg2: saucer_window_edge);
}
unsafe extern "C" {
    pub fn saucer_window_set_minimized(arg1: *mut saucer_window, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_maximized(arg1: *mut saucer_window, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_resizable(arg1: *mut saucer_window, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_fullscreen(arg1: *mut saucer_window, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_always_on_top(arg1: *mut saucer_window, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_click_through(arg1: *mut saucer_window, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_icon(arg1: *mut saucer_window, arg2: *mut saucer_icon);
}
unsafe extern "C" {
    pub fn saucer_window_set_title(arg1: *mut saucer_window, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_window_set_background(arg1: *mut saucer_window, r: u8, g: u8, b: u8, a: u8);
}
unsafe extern "C" {
    pub fn saucer_window_set_decorations(arg1: *mut saucer_window, arg2: saucer_window_decoration);
}
unsafe extern "C" {
    pub fn saucer_window_set_size(arg1: *mut saucer_window, w: ::std::os::raw::c_int, h: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_window_set_max_size(arg1: *mut saucer_window, w: ::std::os::raw::c_int, h: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_window_set_min_size(arg1: *mut saucer_window, w: ::std::os::raw::c_int, h: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_window_set_position(arg1: *mut saucer_window, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_window_on(
        arg1: *mut saucer_window,
        arg2: saucer_window_event,
        callback: *mut ::std::os::raw::c_void,
        clearable: bool,
        userdata: *mut ::std::os::raw::c_void,
    ) -> usize;
}
unsafe extern "C" {
    pub fn saucer_window_once(
        arg1: *mut saucer_window,
        arg2: saucer_window_event,
        callback: *mut ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn saucer_window_off(arg1: *mut saucer_window, arg2: saucer_window_event, arg3: usize);
}
unsafe extern "C" {
    pub fn saucer_window_off_all(arg1: *mut saucer_window, arg2: saucer_window_event);
}
unsafe extern "C" {
    #[doc = " @note Please refer to the documentation in `application.h` on how to use this function."]
    pub fn saucer_window_native(
        arg1: *mut saucer_window,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_webview {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_webview_options {
    _unused: [u8; 0],
}
pub const SAUCER_STATE_STARTED: saucer_state = 0;
pub const SAUCER_STATE_FINISHED: saucer_state = 1;
pub type saucer_state = ::std::os::raw::c_int;
pub const SAUCER_STATE_HANDLED: saucer_status = 0;
pub const SAUCER_STATE_UNHANDLED: saucer_status = 1;
pub type saucer_status = ::std::os::raw::c_int;
pub const SAUCER_SCRIPT_TIME_CREATION: saucer_script_time = 0;
pub const SAUCER_SCRIPT_TIME_READY: saucer_script_time = 1;
pub type saucer_script_time = ::std::os::raw::c_int;
pub const SAUCER_WEBVIEW_EVENT_PERMISSION: saucer_webview_event = 0;
pub const SAUCER_WEBVIEW_EVENT_FULLSCREEN: saucer_webview_event = 1;
pub const SAUCER_WEBVIEW_EVENT_DOM_READY: saucer_webview_event = 2;
pub const SAUCER_WEBVIEW_EVENT_NAVIGATED: saucer_webview_event = 3;
pub const SAUCER_WEBVIEW_EVENT_NAVIGATE: saucer_webview_event = 4;
pub const SAUCER_WEBVIEW_EVENT_MESSAGE: saucer_webview_event = 5;
pub const SAUCER_WEBVIEW_EVENT_REQUEST: saucer_webview_event = 6;
pub const SAUCER_WEBVIEW_EVENT_FAVICON: saucer_webview_event = 7;
pub const SAUCER_WEBVIEW_EVENT_TITLE: saucer_webview_event = 8;
pub const SAUCER_WEBVIEW_EVENT_LOAD: saucer_webview_event = 9;
pub type saucer_webview_event = ::std::os::raw::c_int;
#[doc = " @remark The passed permission requests lifetime ends when the event-callback finishes. To keep it around, it has\n to be explictly copied!"]
pub type saucer_webview_event_permission = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut saucer_webview,
        arg2: *mut saucer_permission_request,
        arg3: *mut ::std::os::raw::c_void,
    ) -> saucer_status,
>;
pub type saucer_webview_event_fullscreen = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_webview, arg2: bool, arg3: *mut ::std::os::raw::c_void) -> saucer_policy,
>;
pub type saucer_webview_event_dom_ready =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut saucer_webview, arg2: *mut ::std::os::raw::c_void)>;
#[doc = " @remark The passed urls lifetime ends when the event-callback finishes. To keep it around, it has\n to be explictly copied!"]
pub type saucer_webview_event_navigated = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_webview, arg2: *mut saucer_url, arg3: *mut ::std::os::raw::c_void),
>;
#[doc = " @remark The passed navigations lifetime ends when the event-callback finishes. It cannot be copied."]
pub type saucer_webview_event_navigate = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut saucer_webview,
        arg2: *mut saucer_navigation,
        arg3: *mut ::std::os::raw::c_void,
    ) -> saucer_policy,
>;
pub type saucer_webview_event_message = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut saucer_webview,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ) -> saucer_status,
>;
#[doc = " @remark The passed urls lifetime ends when the event-callback finishes. To keep it around, it has\n to be explictly copied!"]
pub type saucer_webview_event_request = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_webview, arg2: *mut saucer_url, arg3: *mut ::std::os::raw::c_void),
>;
#[doc = " @remark The passed icons lifetime ends when the event-callback finishes. To keep it around, it has\n to be explictly copied!"]
pub type saucer_webview_event_favicon = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_webview, arg2: *mut saucer_icon, arg3: *mut ::std::os::raw::c_void),
>;
pub type saucer_webview_event_title = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut saucer_webview,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut ::std::os::raw::c_void,
    ),
>;
pub type saucer_webview_event_load = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_webview, arg2: saucer_state, arg3: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    pub fn saucer_webview_options_free(arg1: *mut saucer_webview_options);
}
unsafe extern "C" {
    pub fn saucer_webview_options_new(arg1: *mut saucer_window) -> *mut saucer_webview_options;
}
unsafe extern "C" {
    pub fn saucer_webview_options_set_attributes(arg1: *mut saucer_webview_options, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_webview_options_set_persistent_cookies(arg1: *mut saucer_webview_options, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_webview_options_set_hardware_acceleration(arg1: *mut saucer_webview_options, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_webview_options_set_storage_path(
        arg1: *mut saucer_webview_options,
        arg2: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn saucer_webview_options_set_user_agent(
        arg1: *mut saucer_webview_options,
        arg2: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn saucer_webview_options_append_browser_flag(
        arg1: *mut saucer_webview_options,
        arg2: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn saucer_webview_free(arg1: *mut saucer_webview);
}
unsafe extern "C" {
    pub fn saucer_webview_new(
        arg1: *mut saucer_webview_options,
        error: *mut ::std::os::raw::c_int,
    ) -> *mut saucer_webview;
}
unsafe extern "C" {
    pub fn saucer_webview_url(arg1: *mut saucer_webview, error: *mut ::std::os::raw::c_int) -> *mut saucer_url;
}
unsafe extern "C" {
    pub fn saucer_webview_favicon(arg1: *mut saucer_webview) -> *mut saucer_icon;
}
unsafe extern "C" {
    pub fn saucer_webview_page_title(arg1: *mut saucer_webview, arg2: *mut ::std::os::raw::c_char, arg3: *mut usize);
}
unsafe extern "C" {
    pub fn saucer_webview_dev_tools(arg1: *mut saucer_webview) -> bool;
}
unsafe extern "C" {
    pub fn saucer_webview_context_menu(arg1: *mut saucer_webview) -> bool;
}
unsafe extern "C" {
    pub fn saucer_webview_force_dark(arg1: *mut saucer_webview) -> bool;
}
unsafe extern "C" {
    pub fn saucer_webview_background(arg1: *mut saucer_webview, r: *mut u8, g: *mut u8, b: *mut u8, a: *mut u8);
}
unsafe extern "C" {
    pub fn saucer_webview_bounds(
        arg1: *mut saucer_webview,
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_webview_set_url(arg1: *mut saucer_webview, arg2: *mut saucer_url);
}
unsafe extern "C" {
    pub fn saucer_webview_set_url_str(arg1: *mut saucer_webview, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_set_html(arg1: *mut saucer_webview, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_set_dev_tools(arg1: *mut saucer_webview, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_webview_set_context_menu(arg1: *mut saucer_webview, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_webview_set_force_dark(arg1: *mut saucer_webview, arg2: bool);
}
unsafe extern "C" {
    pub fn saucer_webview_set_background(arg1: *mut saucer_webview, r: u8, g: u8, b: u8, a: u8);
}
unsafe extern "C" {
    pub fn saucer_webview_reset_bounds(arg1: *mut saucer_webview);
}
unsafe extern "C" {
    pub fn saucer_webview_set_bounds(
        arg1: *mut saucer_webview,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_webview_back(arg1: *mut saucer_webview);
}
unsafe extern "C" {
    pub fn saucer_webview_forward(arg1: *mut saucer_webview);
}
unsafe extern "C" {
    pub fn saucer_webview_reload(arg1: *mut saucer_webview);
}
unsafe extern "C" {
    pub fn saucer_webview_serve(arg1: *mut saucer_webview, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_embed(
        arg1: *mut saucer_webview,
        path: *const ::std::os::raw::c_char,
        content: *mut saucer_stash,
        mime: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn saucer_webview_unembed_all(arg1: *mut saucer_webview);
}
unsafe extern "C" {
    pub fn saucer_webview_unembed(arg1: *mut saucer_webview, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_execute(arg1: *mut saucer_webview, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_inject(
        arg1: *mut saucer_webview,
        code: *const ::std::os::raw::c_char,
        run_at: saucer_script_time,
        no_frames: bool,
        clearable: bool,
    ) -> usize;
}
unsafe extern "C" {
    pub fn saucer_webview_uninject_all(arg1: *mut saucer_webview);
}
unsafe extern "C" {
    pub fn saucer_webview_uninject(arg1: *mut saucer_webview, arg2: usize);
}
unsafe extern "C" {
    pub fn saucer_webview_handle_scheme(
        arg1: *mut saucer_webview,
        arg2: *const ::std::os::raw::c_char,
        arg3: saucer_scheme_handler,
        arg4: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn saucer_webview_remove_scheme(arg1: *mut saucer_webview, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_on(
        arg1: *mut saucer_webview,
        arg2: saucer_webview_event,
        callback: *mut ::std::os::raw::c_void,
        clearable: bool,
        userdata: *mut ::std::os::raw::c_void,
    ) -> usize;
}
unsafe extern "C" {
    pub fn saucer_webview_once(
        arg1: *mut saucer_webview,
        arg2: saucer_webview_event,
        callback: *mut ::std::os::raw::c_void,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn saucer_webview_off(arg1: *mut saucer_webview, arg2: saucer_webview_event, arg3: usize);
}
unsafe extern "C" {
    pub fn saucer_webview_off_all(arg1: *mut saucer_webview, arg2: saucer_webview_event);
}
unsafe extern "C" {
    pub fn saucer_webview_register_scheme(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @note Please refer to the documentation in `application.h` on how to use this function."]
    pub fn saucer_webview_native(
        arg1: *mut saucer_webview,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut usize,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_desktop {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_picker_options {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn saucer_picker_options_new() -> *mut saucer_picker_options;
}
unsafe extern "C" {
    pub fn saucer_picker_options_free(arg1: *mut saucer_picker_options);
}
unsafe extern "C" {
    pub fn saucer_picker_options_set_initial(arg1: *mut saucer_picker_options, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @remark Expects the filters in the format of: \"filter1\\0filter2\\0filter3\\0\""]
    pub fn saucer_picker_options_set_filters(
        arg1: *mut saucer_picker_options,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    );
}
unsafe extern "C" {
    pub fn saucer_desktop_free(arg1: *mut saucer_desktop);
}
unsafe extern "C" {
    pub fn saucer_desktop_new(arg1: *mut saucer_application) -> *mut saucer_desktop;
}
unsafe extern "C" {
    pub fn saucer_desktop_mouse_position(
        arg1: *mut saucer_desktop,
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_picker_pick_file(
        arg1: *mut saucer_desktop,
        arg2: *mut saucer_picker_options,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut usize,
        error: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_picker_pick_folder(
        arg1: *mut saucer_desktop,
        arg2: *mut saucer_picker_options,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut usize,
        error: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_picker_pick_files(
        arg1: *mut saucer_desktop,
        arg2: *mut saucer_picker_options,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut usize,
        error: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_picker_save(
        arg1: *mut saucer_desktop,
        arg2: *mut saucer_picker_options,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut usize,
        error: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn saucer_desktop_open(arg1: *mut saucer_desktop, arg2: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_pdf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_pdf_settings {
    _unused: [u8; 0],
}
pub const SAUCER_PDF_LAYOUT_PORTRAIT: saucer_pdf_layout = 0;
pub const SAUCER_PDF_LAYOUT_LANDSCAPE: saucer_pdf_layout = 1;
pub type saucer_pdf_layout = u8;
unsafe extern "C" {
    pub fn saucer_pdf_settings_free(arg1: *mut saucer_pdf_settings);
}
unsafe extern "C" {
    pub fn saucer_pdf_settings_new(arg1: *const ::std::os::raw::c_char) -> *mut saucer_pdf_settings;
}
unsafe extern "C" {
    pub fn saucer_pdf_settings_set_size(arg1: *mut saucer_pdf_settings, w: f64, h: f64);
}
unsafe extern "C" {
    pub fn saucer_pdf_settings_set_orientation(arg1: *mut saucer_pdf_settings, arg2: saucer_pdf_layout);
}
unsafe extern "C" {
    pub fn saucer_pdf_free(arg1: *mut saucer_pdf);
}
unsafe extern "C" {
    pub fn saucer_pdf_new(arg1: *mut saucer_webview) -> *mut saucer_pdf;
}
unsafe extern "C" {
    pub fn saucer_pdf_save(arg1: *mut saucer_pdf, arg2: *mut saucer_pdf_settings);
}
